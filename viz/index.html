<!DOCTYPE html>
<body>
  <hr>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.13/jquery.mousewheel.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/3.0.11/pixi.min.js"></script>
<script>

var pointWidth = 5000;
var signalHeight = 25;
var stageWidth = 800;
var len = 2;

var renderer = PIXI.autoDetectRenderer(stageWidth, 600, { antialias: true });
document.body.appendChild(renderer.view);

// create the root of the scene graph
var stage = new PIXI.Container();
stage.interactive = true;

var lineTracker = new PIXI.Graphics();
stage.addChild(lineTracker);

var global_pos = null;
stage.on('mousemove', function (e) {
  var p = e.data.getLocalPosition(this);
  // console.log('hi');
  // if (p.x >= 0 && p.x < this.width && p.y >= 0 && p.y < this.height) {
  p.x -= 2;
    global_pos = p;
  // }

  lineTracker.clear();
  lineTracker.beginFill(0x333333);
  lineTracker.moveTo(p.x - len, 0);
  lineTracker.lineTo(p.x, 0);
  lineTracker.lineTo(p.x, 10000);
  lineTracker.lineTo(p.x - len, 10000);
  lineTracker.lineTo(p.x - len, 0);
})

function randomPoints(width) {
  var points = [[0, 0]];
  for (var j = 0; j < width; j += 50) {
    if (Math.random() > 0.5) {
      var last = points.slice(-1)[0][1];
      points.push([j, last == 1 ? 0 : 1]);
    }
  }
  points.push([width, 0]);
  return points;
}

var signals = [
  {
    "name": "tx",
    "points": randomPoints(pointWidth),
    "graphics": new PIXI.Graphics(),
  },
  {
    "name": "rx",
    "points": randomPoints(pointWidth),
    "graphics": new PIXI.Graphics(),
  },
];

for (var i = 0; i < signals.length; i++) {
  stage.addChild(signals[i].graphics);
  signals[i].graphics.y = 100 + (i * (signalHeight + 15));
}

var minZoom = stageWidth/pointWidth;
var zoom = minZoom;
var start = 0;
var point = 0;

function redraw(points, g, xmul) {
  g.clear();

  // g.beginFill(0xff0000);
  // var s = point;
  // g.moveTo(s - 4, 25 - 4);
  // g.lineTo(s - 4, 25 + 4);
  // g.lineTo(s + 4, 25 + 4);
  // g.lineTo(s + 4, 25 - 4);
  // g.lineTo(s - 4, 25 - 4);
  // g.endFill();

  g.beginFill(0xffd900);

  if (xmul < minZoom) {
    xmul = minZoom;
  }

  var h = signalHeight - len, y = 0;

  for (var i = 0; i < points.length; i++) {
    var change = false;
    var x = (points[i][0] - start/2) * xmul;
    if (i > 0) {
      var xprev = (points[i-1][0] - start/2) * xmul;
      var dest = y + ((h - len) * (1-points[i-1][1]));
      g.moveTo(xprev, dest);
      g.lineTo(xprev, dest + len);
      g.lineTo(x+len, dest + len);
      g.lineTo(x+len, dest);
      g.lineTo(xprev, dest);
      change = xprev != x;
    }

    if (change) {
      g.moveTo(x, y);
      g.lineTo(x, y+h);
      g.lineTo(x+len, y+h);
      g.lineTo(x+len, y);
      g.lineTo(x, y);
    }
  }

  g.endFill();
}

// run the render loop
animate();

var a = 0;

$(document).on('keydown', function (e) {
  if (!global_pos) {
    return;
  }
  console.log('E', e);
  e.deltaY = (e.keyCode == 65 ? -1 : 1);
  if (e.keyCode != 65 && e.keyCode != 83) {
    return;
  }
  var lastZoom = zoom;
  var less = e.deltaY < 0 ? 0 : 1;
  var delta = Math.min(Math.log(Math.abs(e.deltaY), 10) + 1.5, 4);
  // console.log(less, delta);
  // console.log('current', zoom);
  if (delta > 0 && delta < 5) {
    if (!less) {
      zoom = Math.max(minZoom, zoom * delta);
    } else {
      zoom = Math.max(minZoom, zoom * 1/delta);
    }
  }
  zoom = Math.min(zoom, 400*1000);
  // start *= delta;
  point = global_pos.x;
  if (e.keyCode == 65) {
    start += (global_pos.x / zoom);
  } else if (e.keyCode == 83) {
    start -= (global_pos.x / lastZoom);
    if (start < 0) {
      start = 0;
    }
  }
  console.log('zoom', start, global_pos.x);
})

function animate() {
  // stage.scale.x = Math.abs(Math.cos(a += .02));
  for (var i = 0; i < signals.length; i++) {
    redraw(signals[i].points, signals[i].graphics, zoom);
  }
  renderer.render(stage);
  requestAnimationFrame( animate );
}
</script>
